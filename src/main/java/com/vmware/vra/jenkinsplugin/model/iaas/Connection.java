/*
 * Copyright (c) 2020 VMware, Inc
 *
 *  SPDX-License-Identifier: MIT
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*
 * VMware Cloud Assembly IaaS API
 * A multi-cloud IaaS API for Cloud Automation Services
 *
 * OpenAPI spec version: 2019-01-15
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.vmware.vra.jenkinsplugin.model.iaas;

import com.google.gson.annotations.SerializedName;
import io.swagger.v3.oas.annotations.media.Schema;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

/** Connection */
@javax.annotation.Generated(
    value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen",
    date = "2020-09-09T18:26:35.661905-04:00[America/New_York]")
public class Connection {
  @SerializedName("schema")
  private String schema = null;

  @SerializedName("networkTimeout")
  private Integer networkTimeout = null;

  @SerializedName("metaData")
  private DatabaseMetaData metaData = null;

  @SerializedName("transactionIsolation")
  private Integer transactionIsolation = null;

  @SerializedName("typeMap")
  private Object typeMap = null;

  @SerializedName("catalog")
  private String catalog = null;

  @SerializedName("warnings")
  private SQLWarning warnings = null;

  @SerializedName("clientInfo")
  private Map<String, String> clientInfo = null;

  @SerializedName("closed")
  private Boolean closed = null;

  @SerializedName("readOnly")
  private Boolean readOnly = null;

  @SerializedName("autoCommit")
  private Boolean autoCommit = null;

  @SerializedName("holdability")
  private Integer holdability = null;

  public Connection schema(String schema) {
    this.schema = schema;
    return this;
  }

  /**
   * Get schema
   *
   * @return schema
   */
  @Schema(description = "")
  public String getSchema() {
    return schema;
  }

  public void setSchema(String schema) {
    this.schema = schema;
  }

  public Connection networkTimeout(Integer networkTimeout) {
    this.networkTimeout = networkTimeout;
    return this;
  }

  /**
   * Get networkTimeout
   *
   * @return networkTimeout
   */
  @Schema(description = "")
  public Integer getNetworkTimeout() {
    return networkTimeout;
  }

  public void setNetworkTimeout(Integer networkTimeout) {
    this.networkTimeout = networkTimeout;
  }

  public Connection metaData(DatabaseMetaData metaData) {
    this.metaData = metaData;
    return this;
  }

  /**
   * Get metaData
   *
   * @return metaData
   */
  @Schema(description = "")
  public DatabaseMetaData getMetaData() {
    return metaData;
  }

  public void setMetaData(DatabaseMetaData metaData) {
    this.metaData = metaData;
  }

  public Connection transactionIsolation(Integer transactionIsolation) {
    this.transactionIsolation = transactionIsolation;
    return this;
  }

  /**
   * Get transactionIsolation
   *
   * @return transactionIsolation
   */
  @Schema(description = "")
  public Integer getTransactionIsolation() {
    return transactionIsolation;
  }

  public void setTransactionIsolation(Integer transactionIsolation) {
    this.transactionIsolation = transactionIsolation;
  }

  public Connection typeMap(Object typeMap) {
    this.typeMap = typeMap;
    return this;
  }

  /**
   * Get typeMap
   *
   * @return typeMap
   */
  @Schema(description = "")
  public Object getTypeMap() {
    return typeMap;
  }

  public void setTypeMap(Object typeMap) {
    this.typeMap = typeMap;
  }

  public Connection catalog(String catalog) {
    this.catalog = catalog;
    return this;
  }

  /**
   * Get catalog
   *
   * @return catalog
   */
  @Schema(description = "")
  public String getCatalog() {
    return catalog;
  }

  public void setCatalog(String catalog) {
    this.catalog = catalog;
  }

  public Connection warnings(SQLWarning warnings) {
    this.warnings = warnings;
    return this;
  }

  /**
   * Get warnings
   *
   * @return warnings
   */
  @Schema(description = "")
  public SQLWarning getWarnings() {
    return warnings;
  }

  public void setWarnings(SQLWarning warnings) {
    this.warnings = warnings;
  }

  public Connection clientInfo(Map<String, String> clientInfo) {
    this.clientInfo = clientInfo;
    return this;
  }

  public Connection putClientInfoItem(String key, String clientInfoItem) {
    if (this.clientInfo == null) {
      this.clientInfo = new HashMap<String, String>();
    }
    this.clientInfo.put(key, clientInfoItem);
    return this;
  }

  /**
   * Get clientInfo
   *
   * @return clientInfo
   */
  @Schema(description = "")
  public Map<String, String> getClientInfo() {
    return clientInfo;
  }

  public void setClientInfo(Map<String, String> clientInfo) {
    this.clientInfo = clientInfo;
  }

  public Connection closed(Boolean closed) {
    this.closed = closed;
    return this;
  }

  /**
   * Get closed
   *
   * @return closed
   */
  @Schema(description = "")
  public Boolean isClosed() {
    return closed;
  }

  public void setClosed(Boolean closed) {
    this.closed = closed;
  }

  public Connection readOnly(Boolean readOnly) {
    this.readOnly = readOnly;
    return this;
  }

  /**
   * Get readOnly
   *
   * @return readOnly
   */
  @Schema(description = "")
  public Boolean isReadOnly() {
    return readOnly;
  }

  public void setReadOnly(Boolean readOnly) {
    this.readOnly = readOnly;
  }

  public Connection autoCommit(Boolean autoCommit) {
    this.autoCommit = autoCommit;
    return this;
  }

  /**
   * Get autoCommit
   *
   * @return autoCommit
   */
  @Schema(description = "")
  public Boolean isAutoCommit() {
    return autoCommit;
  }

  public void setAutoCommit(Boolean autoCommit) {
    this.autoCommit = autoCommit;
  }

  public Connection holdability(Integer holdability) {
    this.holdability = holdability;
    return this;
  }

  /**
   * Get holdability
   *
   * @return holdability
   */
  @Schema(description = "")
  public Integer getHoldability() {
    return holdability;
  }

  public void setHoldability(Integer holdability) {
    this.holdability = holdability;
  }

  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Connection connection = (Connection) o;
    return Objects.equals(this.schema, connection.schema)
        && Objects.equals(this.networkTimeout, connection.networkTimeout)
        && Objects.equals(this.metaData, connection.metaData)
        && Objects.equals(this.transactionIsolation, connection.transactionIsolation)
        && Objects.equals(this.typeMap, connection.typeMap)
        && Objects.equals(this.catalog, connection.catalog)
        && Objects.equals(this.warnings, connection.warnings)
        && Objects.equals(this.clientInfo, connection.clientInfo)
        && Objects.equals(this.closed, connection.closed)
        && Objects.equals(this.readOnly, connection.readOnly)
        && Objects.equals(this.autoCommit, connection.autoCommit)
        && Objects.equals(this.holdability, connection.holdability);
  }

  @Override
  public int hashCode() {
    return Objects.hash(
        schema,
        networkTimeout,
        metaData,
        transactionIsolation,
        typeMap,
        catalog,
        warnings,
        clientInfo,
        closed,
        readOnly,
        autoCommit,
        holdability);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Connection {\n");

    sb.append("    schema: ").append(toIndentedString(schema)).append("\n");
    sb.append("    networkTimeout: ").append(toIndentedString(networkTimeout)).append("\n");
    sb.append("    metaData: ").append(toIndentedString(metaData)).append("\n");
    sb.append("    transactionIsolation: ")
        .append(toIndentedString(transactionIsolation))
        .append("\n");
    sb.append("    typeMap: ").append(toIndentedString(typeMap)).append("\n");
    sb.append("    catalog: ").append(toIndentedString(catalog)).append("\n");
    sb.append("    warnings: ").append(toIndentedString(warnings)).append("\n");
    sb.append("    clientInfo: ").append(toIndentedString(clientInfo)).append("\n");
    sb.append("    closed: ").append(toIndentedString(closed)).append("\n");
    sb.append("    readOnly: ").append(toIndentedString(readOnly)).append("\n");
    sb.append("    autoCommit: ").append(toIndentedString(autoCommit)).append("\n");
    sb.append("    holdability: ").append(toIndentedString(holdability)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}
